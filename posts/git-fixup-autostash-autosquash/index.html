<!doctype html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-162787046-2"></script><script>window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-162787046-2');</script><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Using git&#39;s `autostash` and `autosquash` for effortless fixups | Chili J</title><meta name="description" content="Pretty much anything"><meta name="robots" content="index,follow"><meta name="generator" content="Eleventy"><meta name="subject" content="Pretty much anything"><meta name="twitter:card" content="summary"><meta name="twitter:url" content="https://blog.chilij.com/posts/git-fixup-autostash-autosquash/"><meta name="twitter:title" content="Using git&#39;s `autostash` and `autosquash` for effortless fixups"><meta name="twitter:description" content="Using `git rebase` in combination with its `--autostash` and `--autosquash` options makes amending historical commits easy. Using git&#39;s message-based revision syntax makes it even easier."><link rel="author" href="https://blog.chilij.com"><link rel="publisher" href="https://blog.chilij.com"><meta itemprop="name" content="Using git&#39;s `autostash` and `autosquash` for effortless fixups"><meta itemprop="description" content="Using `git rebase` in combination with its `--autostash` and `--autosquash` options makes amending historical commits easy. Using git&#39;s message-based revision syntax makes it even easier."><meta property="og:url" content="https://blog.chilij.com/posts/git-fixup-autostash-autosquash/"><meta property="og:type" content="website"><meta property="og:title" content="Using git&#39;s `autostash` and `autosquash` for effortless fixups"><meta property="og:description" content="Using `git rebase` in combination with its `--autostash` and `--autosquash` options makes amending historical commits easy. Using git&#39;s message-based revision syntax makes it even easier."><meta property="og:site_name" content="Chili J"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://blog.chilij.com/images/og-lambda.png"><meta property="article:author" content="https://blog.chilij.com"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/normalize.css@8.0.1/normalize.css"><link href="http://fonts.googleapis.com/css?family=Lato:300,400,700|Droid+Serif:400,700|Pacifico" rel="stylesheet" type="text/css"><link rel="stylesheet" href="https://use.typekit.net/ooa0ozr.css"><style>code[class*=language-],pre[class*=language-]{color:#393a34;font-family:Consolas,"Bitstream Vera Sans Mono","Courier New",Courier,monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;font-size:.9em;line-height:1.2em;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none}pre>code[class*=language-]{font-size:1em}code[class*=language-] ::-moz-selection,code[class*=language-]::-moz-selection,pre[class*=language-] ::-moz-selection,pre[class*=language-]::-moz-selection{background:#b3d4fc}code[class*=language-] ::selection,code[class*=language-]::selection,pre[class*=language-] ::selection,pre[class*=language-]::selection{background:#b3d4fc}pre[class*=language-]{padding:1em;margin:.5em 0;overflow:auto;border:1px solid #ddd;background-color:#fff}:not(pre)>code[class*=language-]{padding:.2em;padding-top:1px;padding-bottom:1px;background:#f8f8f8;border:1px solid #ddd}.token.cdata,.token.comment,.token.doctype,.token.prolog{color:#998;font-style:italic}.token.namespace{opacity:.7}.token.attr-value,.token.string{color:#e3116c}.token.operator,.token.punctuation{color:#393a34}.token.boolean,.token.constant,.token.entity,.token.inserted,.token.number,.token.property,.token.regex,.token.symbol,.token.url,.token.variable{color:#36acaa}.language-autohotkey .token.selector,.token.atrule,.token.attr-name,.token.keyword{color:#00a4db}.language-autohotkey .token.tag,.token.deleted,.token.function{color:#9a050f}.language-autohotkey .token.keyword,.token.selector,.token.tag{color:#00009f}.token.bold,.token.function,.token.important{font-weight:700}.token.italic{font-style:italic}h1,h2,h3,h4,h5,h6{text-rendering:optimizeLegibility;line-height:1;margin-top:0;font-family:cholla-slab,serif;font-weight:700}h1{font-size:2em;line-height:1.2em;letter-spacing:-2px;text-indent:-3px}h2{font-size:1.7em;line-height:1.2em;letter-spacing:-1px;text-indent:-2px}h3{font-size:1.5em}h4{font-size:1.3em}h5{font-size:1.1em}h6{font-size:1em}.post-content h1,.post-content h2,.post-content h3,.post-content h4,.post-content h5,.post-content h6{margin-top:1.4em;margin-bottom:.8em}.post-template .post-meta,.post-template .post-title{text-align:center}.post-template .post-title{margin:.8em}figure{margin:0;padding:2em 0}figure img{width:100%}body{display:flex;flex-direction:column;align-items:center;min-height:100vh;font-family:letter-gothic-std,monospace;font-size:1.2rem;line-height:1.6em;color:#2c3237;letter-spacing:-.03em;font-weight:400}header#site-head,nav#main-nav{padding:0 16px;flex-basis:80%;max-width:680px;flex-grow:0;flex-shrink:0}.post-title span,a{text-decoration:none;background-color:#2c3237;color:#fff}#site-head{margin:3.3em 0}#blog-logo{background-color:transparent}#blog-logo img{min-width:5.5em;height:auto}.main-nav ul{list-style:none;display:flex;padding:0;margin:0;justify-content:center}.main-nav li{margin:1em}article{display:flex;flex-direction:column;max-width:42rem;margin:0 1.25em;padding:1.6em 0}article footer,article header,article section{flex:0 0 auto}article header{margin:0}article header h1,article header h2,article header h3,article header h4,article header h5,article header h6{margin:0}article p,article pre{margin:1.6em 0 0 0}article section.post-excerpt p{margin:.5em 0 0 0}blockquote{text-align:center;border:1px solid #c3c3c3;margin:2em 0}blockquote p{margin:0;padding:0}pre{font-size:.8em!important;line-height:1.6em!important;overflow:auto!important;background-color:#f7f7f7!important;border:1px solid #eee!important}blockquote,pre{padding:1em 1.4em!important}.post-meta{list-style:none;color:#c3c3c3;font-size:.8em;margin:.2em 0;padding:0}main{margin-bottom:3em;max-width:100%}@media (max-width:42rem){body{font-size:1rem}}.direct-link{background:0 0;font-size:.7em;opacity:.2;transition:opacity .2s}.direct-link:hover{opacity:1}.post-content img{width:100%;border-radius:.1em}img+em{color:#999}.end-mark{display:flex;align-items:center;justify-content:center;padding:1em 0}.end-mark>img{max-width:3em}</style></head><body class="post-template"><nav class="main-nav"><ul class="nav" role="menu"><li class="nav-item"><a href="/">Posts</a></li><li class="nav-item"><a href="/about/">About</a></li><li class="nav-item"><a href="https://www.chilij.com">Home</a></li></ul></nav><main class="content" role="main"><article class="post"><div class="post-meta"><time datetime="2020-06-14">14 Jun 2020</time></div><h1 class="post-title"><span>Using git&#39;s `autostash` and `autosquash` for effortless fixups</span></h1><section class="post-content"><p>Applying fixups to your last commit in <code>git</code> is pretty easy using <code>git commit --amend</code>, but applying fixups to older commits can be much more involved.</p><p>Using <code>git rebase</code> in combination with its <code>--autostash</code> and <code>--autosquash</code> options makes these fixups a lot easier. Combining a rebase with git's message-based revision syntax is a powerful way to effortlessly apply commit fixups.</p><blockquote><p>If you want to skip the explanations and get right to a useful shell function, <a href="#putting-it-all-together">skip to the last section</a></p></blockquote><h2 id="the-na%C3%AFve-way">The NaÃ¯ve Way <a class="direct-link" href="#the-na%C3%AFve-way">ðŸ”—</a></h2><p>Before I knew about <code>--autostash</code> and <code>--autosquash</code> these are the steps I used to go through to fixup historical commits:</p><ol><li>Stage and commit the files I want to apply during the fixup</li><li><code>git stash</code> the remaining, unstaged, unrelated files</li><li><code>git log</code> and copy the hash of the revision I want to amend</li><li><code>git rebase -i &lt;commit-hash&gt;~</code></li><li>In the text editor, change the command for my fixup commit from <code>pick</code> to <code>fixup</code></li><li>Reorder the commits so that my fixup commit is applied after the commit to be fixed</li><li>Execute the rebase</li><li><code>git stash pop</code> to restore the unrelated changes to my working tree</li></ol><p>There are 4 big areas in which this workflow can be improved:</p><ol><li>Stashing and unstashing unrelated changes, improved with <code>--autostash</code></li><li>Reordering and squashing the fixup commit, improved with <code>--autosquash</code></li><li>Selecting the revision to fix, improved with <code>:/</code></li><li>Having to use a text editor for the interactive rebase, improved by using <code>GIT_SEQUENCE_EDITOR</code></li></ol><h2 id="--autostash">--autostash <a class="direct-link" href="#--autostash">ðŸ”—</a></h2><p>Git's interactive rebase provides an <code>--autostash</code> option which will automatically stash uncommitted changes, then pop those changes back into your working tree after the rebase is executed.</p><p>Git only allows rebases when the working tree is clean, <em>i.e.</em> without any staged or unstaged changes, so if you're in the spot where you're not ready to commit changes, but need to perform a rebase, you must first stash your changes and then unstash them later on.</p><p><code>git rebase -i --autostash</code> takes care of this for us, and saves us from having to perform steps 2 and 9 in the naÃ¯ve workflow.</p><pre class="language-shell"><code class="language-shell">$ <span class="token function">git</span> status<br><span class="token comment"># Changes not staged for commit:</span><br><span class="token comment">#   modified:   README.md</span><br><br><span class="token comment"># The working tree is dirty so regular rebase is forbidden</span><br>$ <span class="token function">git</span> rebase -i HEAD~2<br><span class="token comment"># Cannot rebase: You have unstaged changes.</span><br><span class="token comment"># Please commit or stash them.</span><br><br><span class="token comment"># Using --autostash allows us to rebase anyway</span><br>$ <span class="token function">git</span> rebase -i --autostash HEAD~2<br><span class="token comment"># Created autostash: 487c77a</span><br><span class="token comment"># HEAD is now at e375c7a</span><br><span class="token comment"># Applied autostash.</span><br><span class="token comment"># Successfully rebased and updated refs/heads/master.</span><br><br><span class="token comment"># The dirty working tree is preserved through the rebase</span><br>$ <span class="token function">git</span> status<br><span class="token comment"># Changes not staged for commit:</span><br><span class="token comment">#   modified:   README.md</span></code></pre><h2 id="--autosquash">--autosquash <a class="direct-link" href="#--autosquash">ðŸ”—</a></h2><p>Git's interactive rebase provides an <code>--autosquash</code> option which will help us in two ways:</p><ol><li>It will reorder commits with log messages starting with <code>fixup!</code> or <code>squash!</code> so that they are applied immediately after the commits with the same title (following those prefixes)</li><li>It will change the rebase command to <code>fixup</code> or <code>squash</code>, respectively</li></ol><p>So if we can get a fixup commit titled <code>&quot;fixup! &lt;title of commit to fix&gt;&quot;</code>, <code>git rebase -i --autosquash</code> will save us from having to perform steps 6 and 7 from the naÃ¯ve workflow.</p><p>How can we get one of these commits? Rather than manually typing out <code>fixup!</code> in your fixup commit messages, git provides some help: <code>git commit --fixup</code></p><pre class="language-shell"><code class="language-shell">$ <span class="token function">git</span> log --oneline<br><span class="token comment"># 3333333 (HEAD) Adds dev dependencies.</span><br><span class="token comment"># 2222222 Updates README.</span><br><span class="token comment"># 1111111 Adds framework boilerplate.</span><br><br>$ <span class="token function">git</span> commit --fixup <span class="token number">2222222</span><br>$ <span class="token function">git</span> log --oneline<br><span class="token comment"># 4444444 (HEAD) fixup! Updates README.</span><br><span class="token comment"># 3333333 Adds dev dependencies.</span><br><span class="token comment"># 2222222 Updates README.</span><br><span class="token comment"># 1111111 Adds framework boilerplate.</span><br><br>$ <span class="token function">git</span> rebase -i --autosquash HEAD~4<br><span class="token comment"># * Shown in your text editor:</span><br><span class="token comment"># pick 1111111 Adds framework boilerplate.</span><br><span class="token comment"># pick 2222222 Updates README.</span><br><span class="token comment"># fixup 4444444 fixup! Updates README.</span><br><span class="token comment"># pick 3333333 Adds dev dependencies.</span><br><br>$ <span class="token function">git</span> log --oneline<br><span class="token comment"># 6666666 (HEAD) Adds dev dependencies.</span><br><span class="token comment"># 5555555 Updates README.</span><br><span class="token comment"># 1111111 Adds framework boilerplate.</span></code></pre><p>In this example, a fixup is committed for commit <code>2222222</code>, which shows up with <code>fixup!</code> in its commit title, and ends up getting reordered and labelled as <code>fixup</code> during the rebase.</p><p>After the rebase is executed you can see that the commit history has been modified, starting at commit <code>5555555</code> (previously <code>2222222</code>) where the fixup was applied.</p><h2 id="text-based-revision-selection-with-%3A%2F">Text-based revision selection with <code>:/</code> <a class="direct-link" href="#text-based-revision-selection-with-%3A%2F">ðŸ”—</a></h2><p>In the previous example, in order to create the fixup commit with <code>git commit --fixup 2222222</code>, we used the commit hash as the identifier (which we found through <code>git log</code>), but there's a more intuitive way we can specify which commit we want to fixup, using <code>:/</code>.</p><p>Using <code>:/</code> as a revision identifier tells git to find the most-recent commit which matches the text (really a regular expression) following those tokens.<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup> For example:</p><pre class="language-shell"><code class="language-shell">$ <span class="token function">git</span> log --oneline<br><span class="token comment"># 3333333 (HEAD) Adds dev dependencies.</span><br><span class="token comment"># 2222222 Updates README.</span><br><span class="token comment"># 1111111 Adds framework boilerplate.</span><br><br>$ <span class="token function">git</span> show :/framework<br><span class="token comment"># commit 1111111111111111111111111111111111111111</span><br><span class="token comment"># Author: Chili Johnson</span><br><span class="token comment"># Date:   Apr 20 04:20:00 2020 -0000</span><br><span class="token comment"># </span><br><span class="token comment">#     Adds framework boilerplate.</span><br><span class="token comment"># â€¦</span></code></pre><p>Now we can identify the commit to fix using its commit message, instead of having to find and copy the hash of the commit we want to fix. This eliminates part of step 4 of the naÃ¯ve workflow.</p><h2 id="non-interactive-interactive-rebase">Non-interactive interactive rebase <a class="direct-link" href="#non-interactive-interactive-rebase">ðŸ”—</a></h2><p>Now we have most of the parts we need for an optimized fixup workflow, but there's still the problem of <code>--autosquash</code> and <code>--autostash</code> only working with interactive rebases. Those two options already do everything we need to do during the rebase so opening up a text editor isn't useful anymore.</p><p>To disable opening a text editor during the interactive rebase, we can use the <code>GIT_SEQUENCE_EDITOR</code> environment variable to override the editor which git tries to open.<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></p><p>Overriding it to a program/command which does nothing and exits cleanly will turn an interactive rebase into a non-interactive rebase, while retaining interactive-only features like the two options we're interested in.</p><pre class="language-shell"><code class="language-shell"><span class="token comment"># The rebase succeeds without ever opening a text editor</span><br>$ <span class="token assign-left variable">GIT_SEQUENCE_EDITOR</span><span class="token operator">=</span>: <span class="token function">git</span> rebase -i HEAD~2<br><span class="token comment"># Successfully rebased and updated refs/heads/master.</span></code></pre><p>Here we're using many shells' built-in <code>:</code> command to do nothing and exit cleanly, which allows the rebase to continue on without requiring any interaction.</p><h1 id="putting-it-all-together">Putting it all together <a class="direct-link" href="#putting-it-all-together">ðŸ”—</a></h1><p>Here is a shell function I use (with <code>zsh</code>) which combines all of these optimizations into one command which can be used to fixup commits identified by part of their commit message:</p><pre class="language-shell"><code class="language-shell"><span class="token function-name function">fixup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token assign-left variable">title_match</span><span class="token operator">=</span><span class="token string">"<span class="token variable">${@<span class="token operator">:</span>1}</span>"</span><br><br>  <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token entity" title="\n">\n</span>This operation will rebase:<span class="token entity" title="\n">\n</span>"</span><br><br>  <span class="token function">git</span> --no-pager log --oneline <span class="token string">"HEAD^{/<span class="token variable">$title_match</span>}^..HEAD"</span> --reverse<br><br>  <span class="token keyword">if</span> <span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token variable">$?</span> -ne <span class="token number">0</span> <span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span><br>    <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token entity" title="\n">\n</span>Could not find a commit with title matching: <span class="token entity" title="\&quot;">\"</span><span class="token variable">$title_match</span><span class="token entity" title="\&quot;">\"</span>"</span><br>    <span class="token builtin class-name">return</span><br>  <span class="token keyword">fi</span><br><br>  <span class="token builtin class-name">echo</span><br>  <span class="token builtin class-name">read</span> -q <span class="token string">"REPLY?Are you sure? "</span><br>  <span class="token builtin class-name">echo</span><br><br>  <span class="token keyword">if</span> <span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token environment constant">$REPLY</span> <span class="token operator">=</span>~ ^<span class="token punctuation">[</span>Yy<span class="token punctuation">]</span>$ <span class="token punctuation">]</span><span class="token punctuation">]</span><br>  <span class="token keyword">then</span><br>    <span class="token function">git</span> commit --fixup <span class="token string">":/<span class="token variable">$title_match</span>"</span> <span class="token operator">&amp;&amp;</span> <span class="token assign-left variable">GIT_SEQUENCE_EDITOR</span><span class="token operator">=</span>: <span class="token function">git</span> rebase --interactive --autostash --autosquash <span class="token string">"HEAD^^{/<span class="token variable">$title_match</span>}^"</span><br>  <span class="token keyword">fi</span><br><span class="token punctuation">}</span></code></pre><p>First it prints out which commits will be affected by this rebase and asks for confirmation that all looks good. Then it proceeds to commit any staged changes (stashing any unstaged changes), performs a non-interactive, &quot;interactive&quot; rebase to apply the fixup, and finally restores the unstaged changes to the working tree.</p><p>It accepts one argument, the commit message title fragment (regex) to match the commit intended to be fixed.</p><blockquote><p>Thanks to <a href="https://www.verychill.biz/" target="_blank">Jesse Jenks</a> for workshopping this function and making it even better!</p></blockquote><p>An example usage:</p><pre class="language-shell"><code class="language-shell">$ <span class="token function">git</span> log --oneline<br><span class="token comment"># 3333333 (HEAD) Adds dev dependencies.</span><br><span class="token comment"># 2222222 Updates the readme with an outro.</span><br><span class="token comment"># 1111111 Adds framework boilerplate.</span><br><br>$ <span class="token builtin class-name">echo</span> <span class="token string">"Thanks for reading"</span> <span class="token operator">>></span> README.md<br>$ <span class="token builtin class-name">echo</span> <span class="token string">"Do whatever you want"</span> <span class="token operator">></span> LICENSE<br>$ <span class="token function">git</span> <span class="token function">add</span> README.md<br>$ <span class="token function">git</span> status<br><span class="token comment"># Changes to be committed:</span><br><span class="token comment">#   modified:   README.md</span><br><span class="token comment"># </span><br><span class="token comment"># Changes not staged for commit:</span><br><span class="token comment">#   modified:   LICENSE</span><br><br>$ fixup outro<br><span class="token comment"># This operation will rebase:</span><br><span class="token comment"># </span><br><span class="token comment"># 2222222 Updates the readme with an outro.</span><br><span class="token comment"># 3333333 (HEAD) Adds dev dependencies.</span><br><span class="token comment"># </span><br><span class="token comment"># Are you sure? y</span><br><span class="token comment"># [master 4444444] fixup! Updates the readme with an outro.</span><br><span class="token comment">#  1 file changed, 1 insertion(+), 1 deletion(-)</span><br><span class="token comment"># Created autostash: 2f16c33</span><br><span class="token comment"># HEAD is now at 4444444 fixup! Updates the readme with an outro.</span><br><span class="token comment"># Applied autostash.</span><br><span class="token comment"># Successfully rebased and updated refs/heads/master.</span><br><br>$ <span class="token function">git</span> log --oneline<br><span class="token comment"># 6666666 (HEAD) Adds dev dependencies.</span><br><span class="token comment"># 5555555 Updates the readme with an outro.</span><br><span class="token comment"># 1111111 Adds framework boilerplate.</span><br><br>$ <span class="token function">git</span> status<br><span class="token comment"># Changes not staged for commit:</span><br><span class="token comment">#   modified:   LICENSE</span></code></pre><p>By making use of <code>--autostash</code>, <code>--autosquash</code>, <code>:/</code>, and <code>GIT_SEQUENCE_EDITOR</code>, we've been able to distill that 9-step fixup workflowâ€”which demanded multiple interactive steps and a copy-paste jobâ€”into a single, intuitive command which allows you to apply fixups for selective files while maintaining a dirty working tree.</p><p>I use this all the time in my daily workflow!</p><h4 id="footnotes">Footnotes <a class="direct-link" href="#footnotes">ðŸ”—</a></h4><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://git-scm.com/docs/gitrevisions#Documentation/gitrevisions.txt-emlttextgtemegemfixnastybugem">Git Revisions Syntax</a> <a href="#fnref1" class="footnote-backref">â†©ï¸Ž</a></p></li><li id="fn2" class="footnote-item"><p><a href="https://stackoverflow.com/questions/29094595/git-interactive-rebase-without-opening-the-editor#answer-29094904">Stack Overflow: Git interactive rebase without opening the editor</a> <a href="#fnref2" class="footnote-backref">â†©ï¸Ž</a></p></li></ol></section></section></article><footer><div class="end-mark"><img src="/images/lambda.svg" alt="End Mark"></div></footer></main></body></html>