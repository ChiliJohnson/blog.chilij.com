<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
	<title>Chili J</title>
	<subtitle>Pretty much anything</subtitle>
	
	<link href="https://blog.chilij.com/feed/feed.xml" rel="self"/>
	<link href="https://blog.chilij.com"/>
	<updated>2020-06-14T00:00:00+00:00</updated>
	<id></id>
	<author>
		<name>Chili Johnson</name>
		<email>ChiliJohnson@chilij.com</email>
	</author>
	
	<entry>
		<title>Connecting to your AirPods with a shell script (and keyboard shortcut)</title>
		<link href="https://blog.chilij.com/posts/shell-script-airpods/"/>
		<updated>2020-03-08T00:00:00+00:00</updated>
		<id>https://blog.chilij.com/posts/shell-script-airpods/</id>
		<content type="html">&lt;p&gt;Swapping between devices while using AirPods still isn&#39;t quite as seamless as it could be, especially when swapping from an iPhone to a Mac, where at the very least you&#39;ll be clicking around the menu bar in the sound options, and sometimes even be navigating the bluetooth menu.&lt;/p&gt;
&lt;p&gt;Being able to connect to your AirPods, and then switch your Mac&#39;s audio device over programmatically, can save you a lot of clicks if you spend a lot of time in your terminal, and opens up many more opportunities for automation.&lt;/p&gt;
&lt;p&gt;Connecting to your AirPods requires two distinct steps:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Making sure your AirPods are connected to your Mac via bluetooth&lt;/li&gt;
&lt;li&gt;Once connected, making sure your AirPods are selected as your audio output device&lt;/li&gt;
&lt;li&gt;Optionally: setting a keyboard shortcut to be able to swap devices at any time&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;the-requirements&quot;&gt;The Requirements &lt;a class=&quot;direct-link&quot; href=&quot;#the-requirements&quot;&gt;ðŸ”—&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;You&#39;ll need to install two packages to be able to connect to your AirPods in a shell script:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/lapfelix/BluetoothConnector&quot;&gt;bluetoothconnector&lt;/a&gt; which allows you to connect to / disconnect from bluetooth devices&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/deweller/switchaudio-osx/&quot;&gt;switchaudio-osx&lt;/a&gt; which allows you to select your Mac&#39;s current audio input/output devices&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Both of these can be easily installed using &lt;code&gt;brew&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&quot;language-shell&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;brew &lt;span class=&quot;token function&quot;&gt;install&lt;/span&gt; bluetoothconnector switchaudio-osx&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;connecting-via-bluetooth&quot;&gt;Connecting via Bluetooth &lt;a class=&quot;direct-link&quot; href=&quot;#connecting-via-bluetooth&quot;&gt;ðŸ”—&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The first step is making sure your AirPods are actually connected to your Mac via bluetooth.&lt;/p&gt;
&lt;p&gt;As far as I can tell, &lt;code&gt;BluetoothConnector&lt;/code&gt; doesn&#39;t have a great, pipeline-compatible CLI so you have to do a bit of ugly string mangling to connect to your airpods.&lt;br&gt;
Here&#39;s each step involved, split up with some explanation of each part&lt;/p&gt;
&lt;pre class=&quot;language-shell&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;# A device name to `grep` for from the available bluetooth devices&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token assign-left variable&quot;&gt;DEVICE_NAME&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;airpods pro&quot;&lt;/span&gt;&lt;br&gt;&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;# Retrieve the bluetooth physical address for your device&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token assign-left variable&quot;&gt;device_address&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token variable&quot;&gt;&lt;span class=&quot;token variable&quot;&gt;`&lt;/span&gt;BluetoothConnector &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;grep&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&#39; - &#39;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;grep&lt;/span&gt; -i &lt;span class=&quot;token string&quot;&gt;&quot;&lt;span class=&quot;token variable&quot;&gt;$DEVICE_NAME&lt;/span&gt;&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;cut&lt;/span&gt; -d &lt;span class=&quot;token string&quot;&gt;&#39; &#39;&lt;/span&gt; -f &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token variable&quot;&gt;`&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;# Connect to the device by its physical address&lt;/span&gt;&lt;br&gt;BluetoothConnector --connect &lt;span class=&quot;token variable&quot;&gt;$device_address&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A one-liner which packages this all up:&lt;/p&gt;
&lt;pre class=&quot;language-shell&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;BluetoothConnector --connect &lt;span class=&quot;token variable&quot;&gt;&lt;span class=&quot;token variable&quot;&gt;`&lt;/span&gt;BluetoothConnector &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;grep&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&#39; - &#39;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;grep&lt;/span&gt; -i &lt;span class=&quot;token string&quot;&gt;&quot;airpods pro&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;cut&lt;/span&gt; -d &lt;span class=&quot;token string&quot;&gt;&#39; &#39;&lt;/span&gt; -f &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token variable&quot;&gt;`&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;selecting-the-audio-output-device&quot;&gt;Selecting the audio output device &lt;a class=&quot;direct-link&quot; href=&quot;#selecting-the-audio-output-device&quot;&gt;ðŸ”—&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Once your AirPods are connected via bluetooth, they must be set as your current audio output device.&lt;/p&gt;
&lt;p&gt;If you know the &lt;em&gt;exact&lt;/em&gt; name of your AirPods, it&#39;s pretty straightforward to set them as your default audio device.&lt;/p&gt;
&lt;pre class=&quot;language-shell&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;SwitchAudioSource -s &lt;span class=&quot;token string&quot;&gt;&quot;Chiliâ€™s AirPods Pro&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;By default, AirPods are named with a &lt;strong&gt;right single quotation mark&lt;/strong&gt;, not an apostrophe. You should avoid typing out the name by hand, and instead copy the name from the output of &lt;code&gt;SwitchAudioSource -a&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Similarly, &lt;code&gt;switchaudio-osx&lt;/code&gt; doesn&#39;t seem to have a pipeline-friendly CLI, so more string-mangling is in order here:&lt;/p&gt;
&lt;pre class=&quot;language-shell&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;&lt;span class=&quot;token assign-left variable&quot;&gt;DEVICE_NAME&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;airpods pro&quot;&lt;/span&gt;&lt;br&gt;&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;# Resolve the full audio device name by matching available devices using $DEVICE_NAME&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token assign-left variable&quot;&gt;full_audio_device_name&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token variable&quot;&gt;&lt;span class=&quot;token variable&quot;&gt;`&lt;/span&gt;SwitchAudioSource -a -t output &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;grep&lt;/span&gt; -i &lt;span class=&quot;token string&quot;&gt;&quot;&lt;span class=&quot;token variable&quot;&gt;$DEVICE_NAME&lt;/span&gt;&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;sed&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&#39;s/ (.*//&#39;&lt;/span&gt;&lt;span class=&quot;token variable&quot;&gt;`&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;# Set the default audio output device&lt;/span&gt;&lt;br&gt;SwitchAudioSource -s &lt;span class=&quot;token string&quot;&gt;&quot;&lt;span class=&quot;token variable&quot;&gt;$full_audio_device_name&lt;/span&gt;&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Another one-liner that wraps this all up:&lt;/p&gt;
&lt;pre class=&quot;language-shell&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;SwitchAudioSource -s &lt;span class=&quot;token string&quot;&gt;&quot;$(SwitchAudioSource -a -t output | grep -i &#39;airpods pro&#39; | sed &#39;s/ (.*//&#39;)&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;putting-it-all-together&quot;&gt;Putting it all together &lt;a class=&quot;direct-link&quot; href=&quot;#putting-it-all-together&quot;&gt;ðŸ”—&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Here is a script I use which combines both the Bluetooth connection steps and output device selection.&lt;/p&gt;
&lt;p&gt;When invoked multiple times, this script will swap between using AirPods and another audio device by default (in this case &lt;code&gt;MacBook Pro Speakers&lt;/code&gt;):&lt;/p&gt;
&lt;pre class=&quot;language-shell&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;&lt;span class=&quot;token shebang important&quot;&gt;#!/bin/bash -xe&lt;/span&gt;&lt;br&gt;&lt;br&gt;&lt;span class=&quot;token assign-left variable&quot;&gt;TARGET_DEVICE_NAME&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;airpods pro&quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token assign-left variable&quot;&gt;DEFAULT_AUDIO_DEVICE&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;MacBook Pro Speakers&quot;&lt;/span&gt;&lt;br&gt;&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;# Connect via Bluetooth&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token assign-left variable&quot;&gt;device_address&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token variable&quot;&gt;&lt;span class=&quot;token variable&quot;&gt;`&lt;/span&gt;BluetoothConnector &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;grep&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&#39; - &#39;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;grep&lt;/span&gt; -i &lt;span class=&quot;token string&quot;&gt;&quot;&lt;span class=&quot;token variable&quot;&gt;$TARGET_DEVICE_NAME&lt;/span&gt;&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;cut&lt;/span&gt; -d &lt;span class=&quot;token string&quot;&gt;&#39; &#39;&lt;/span&gt; -f &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token variable&quot;&gt;`&lt;/span&gt;&lt;/span&gt;&lt;br&gt;BluetoothConnector --connect &lt;span class=&quot;token variable&quot;&gt;$device_address&lt;/span&gt;&lt;br&gt;&lt;br&gt;&lt;span class=&quot;token assign-left variable&quot;&gt;target_audio_device&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token variable&quot;&gt;&lt;span class=&quot;token variable&quot;&gt;`&lt;/span&gt;SwitchAudioSource -a -t output &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;grep&lt;/span&gt; -i &lt;span class=&quot;token string&quot;&gt;&quot;&lt;span class=&quot;token variable&quot;&gt;$TARGET_DEVICE_NAME&lt;/span&gt;&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;sed&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&#39;s/ (.*//&#39;&lt;/span&gt;&lt;span class=&quot;token variable&quot;&gt;`&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token assign-left variable&quot;&gt;current_audio_device&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token variable&quot;&gt;&lt;span class=&quot;token variable&quot;&gt;`&lt;/span&gt;SwitchAudioSource -c&lt;span class=&quot;token variable&quot;&gt;`&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;# Only toggle between devices when the target device is available&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt; -z &lt;span class=&quot;token string&quot;&gt;&quot;&lt;span class=&quot;token variable&quot;&gt;$target_audio_device&lt;/span&gt;&quot;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;then&lt;/span&gt;&lt;br&gt;&lt;br&gt;  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;&lt;span class=&quot;token variable&quot;&gt;$current_audio_device&lt;/span&gt;&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;&lt;span class=&quot;token variable&quot;&gt;$target_audio_device&lt;/span&gt;&quot;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;then&lt;/span&gt;&lt;br&gt;    SwitchAudioSource -s &lt;span class=&quot;token string&quot;&gt;&quot;&lt;span class=&quot;token variable&quot;&gt;$target_audio_device&lt;/span&gt;&quot;&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt;&lt;br&gt;    SwitchAudioSource -s &lt;span class=&quot;token string&quot;&gt;&quot;&lt;span class=&quot;token variable&quot;&gt;$DEFAULT_AUDIO_DEVICE&lt;/span&gt;&quot;&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token keyword&quot;&gt;fi&lt;/span&gt;&lt;br&gt;&lt;br&gt;&lt;span class=&quot;token keyword&quot;&gt;fi&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;bonus%3A-do-it-all-with-a-keyboard-shortcut&quot;&gt;Bonus: do it all with a keyboard shortcut &lt;a class=&quot;direct-link&quot; href=&quot;#bonus%3A-do-it-all-with-a-keyboard-shortcut&quot;&gt;ðŸ”—&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Once you&#39;ve saved this shell script somewhere you can invoke it whenever you need from your terminal, but even better is being able to invoke it at any time, from any app.&lt;/p&gt;
&lt;p&gt;To do this you can use a surprisingly-refined (despite its terrible name), little utility: &lt;a href=&quot;https://github.com/deseven/icanhazshortcut/&quot;&gt;ICanHazShortcut&lt;/a&gt;. Also conveniently available via &lt;code&gt;brew&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&quot;language-shell&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;brew cask &lt;span class=&quot;token function&quot;&gt;install&lt;/span&gt; icanhazshortcut&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Once installed you can run the app and add any keyboard shortcut pointed at the shell script from the previous session. I happen to use &lt;code&gt;Shift+Cmd+Home&lt;/code&gt; as my shortcut.&lt;/p&gt;
&lt;h2 id=&quot;automate-your-&#39;pods&quot;&gt;Automate your &#39;Pods &lt;a class=&quot;direct-link&quot; href=&quot;#automate-your-&#39;pods&quot;&gt;ðŸ”—&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;That&#39;s all that&#39;s involved with connecting to, and using your AirPods from the command-line. Now that you can control your audio devices using scripts, a whole new area of automation opens up; like connecting to your AirPods automatically whenever you open a music app, or showing notifications when your bluetooth audio devices become available.&lt;/p&gt;
</content>
	</entry>
	
	<entry>
		<title>Using git&#39;s `autostash` and `autosquash` for effortless fixups</title>
		<link href="https://blog.chilij.com/posts/git-fixup-autostash-autosquash/"/>
		<updated>2020-06-14T00:00:00+00:00</updated>
		<id>https://blog.chilij.com/posts/git-fixup-autostash-autosquash/</id>
		<content type="html">&lt;p&gt;Applying fixups to your last commit in &lt;code&gt;git&lt;/code&gt; is pretty easy using &lt;code&gt;git commit --amend&lt;/code&gt;, but applying fixups to older commits can be much more involved.&lt;/p&gt;
&lt;p&gt;Using &lt;code&gt;git rebase&lt;/code&gt; in combination with its &lt;code&gt;--autostash&lt;/code&gt; and &lt;code&gt;--autosquash&lt;/code&gt; options makes these fixups a lot easier. Combining a rebase with git&#39;s message-based revision syntax is a powerful way to effortlessly apply commit fixups.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;If you want to skip the explanations and get right to a useful shell function, &lt;a href=&quot;#putting-it-all-together&quot;&gt;skip to the last section&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;the-na%C3%AFve-way&quot;&gt;The NaÃ¯ve Way &lt;a class=&quot;direct-link&quot; href=&quot;#the-na%C3%AFve-way&quot;&gt;ðŸ”—&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Before I knew about &lt;code&gt;--autostash&lt;/code&gt; and &lt;code&gt;--autosquash&lt;/code&gt; these are the steps I used to go through to fixup historical commits:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Stage and commit the files I want to apply during the fixup&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git stash&lt;/code&gt; the remaining, unstaged, unrelated files&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git log&lt;/code&gt; and copy the hash of the revision I want to amend&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git rebase -i &amp;lt;commit-hash&amp;gt;~&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;In the text editor, change the command for my fixup commit from &lt;code&gt;pick&lt;/code&gt; to &lt;code&gt;fixup&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Reorder the commits so that my fixup commit is applied after the commit to be fixed&lt;/li&gt;
&lt;li&gt;Execute the rebase&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git stash pop&lt;/code&gt; to restore the unrelated changes to my working tree&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;There are 4 big areas in which this workflow can be improved:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Stashing and unstashing unrelated changes, improved with &lt;code&gt;--autostash&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Reordering and squashing the fixup commit, improved with &lt;code&gt;--autosquash&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Selecting the revision to fix, improved with &lt;code&gt;:/&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Having to use a text editor for the interactive rebase, improved by using &lt;code&gt;GIT_SEQUENCE_EDITOR&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;--autostash&quot;&gt;--autostash &lt;a class=&quot;direct-link&quot; href=&quot;#--autostash&quot;&gt;ðŸ”—&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Git&#39;s interactive rebase provides an &lt;code&gt;--autostash&lt;/code&gt; option which will automatically stash uncommitted changes, then pop those changes back into your working tree after the rebase is executed.&lt;/p&gt;
&lt;p&gt;Git only allows rebases when the working tree is clean, &lt;em&gt;i.e.&lt;/em&gt; without any staged or unstaged changes, so if you&#39;re in the spot where you&#39;re not ready to commit changes, but need to perform a rebase, you must first stash your changes and then unstash them later on.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git rebase -i --autostash&lt;/code&gt; takes care of this for us, and saves us from having to perform steps 2 and 9 in the naÃ¯ve workflow.&lt;/p&gt;
&lt;pre class=&quot;language-shell&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;$ &lt;span class=&quot;token function&quot;&gt;git&lt;/span&gt; status&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;# Changes not staged for commit:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;#   modified:   README.md&lt;/span&gt;&lt;br&gt;&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;# The working tree is dirty so regular rebase is forbidden&lt;/span&gt;&lt;br&gt;$ &lt;span class=&quot;token function&quot;&gt;git&lt;/span&gt; rebase -i HEAD~2&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;# Cannot rebase: You have unstaged changes.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;# Please commit or stash them.&lt;/span&gt;&lt;br&gt;&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;# Using --autostash allows us to rebase anyway&lt;/span&gt;&lt;br&gt;$ &lt;span class=&quot;token function&quot;&gt;git&lt;/span&gt; rebase -i --autostash HEAD~2&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;# Created autostash: 487c77a&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;# HEAD is now at e375c7a&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;# Applied autostash.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;# Successfully rebased and updated refs/heads/master.&lt;/span&gt;&lt;br&gt;&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;# The dirty working tree is preserved through the rebase&lt;/span&gt;&lt;br&gt;$ &lt;span class=&quot;token function&quot;&gt;git&lt;/span&gt; status&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;# Changes not staged for commit:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;#   modified:   README.md&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;--autosquash&quot;&gt;--autosquash &lt;a class=&quot;direct-link&quot; href=&quot;#--autosquash&quot;&gt;ðŸ”—&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Git&#39;s interactive rebase provides an &lt;code&gt;--autosquash&lt;/code&gt; option which will help us in two ways:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;It will reorder commits with log messages starting with &lt;code&gt;fixup!&lt;/code&gt; or &lt;code&gt;squash!&lt;/code&gt; so that they are applied immediately after the commits with the same title (following those prefixes)&lt;/li&gt;
&lt;li&gt;It will change the rebase command to &lt;code&gt;fixup&lt;/code&gt; or &lt;code&gt;squash&lt;/code&gt;, respectively&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;So if we can get a fixup commit titled &lt;code&gt;&amp;quot;fixup! &amp;lt;title of commit to fix&amp;gt;&amp;quot;&lt;/code&gt;, &lt;code&gt;git rebase -i --autosquash&lt;/code&gt; will save us from having to perform steps 6 and 7 from the naÃ¯ve workflow.&lt;/p&gt;
&lt;p&gt;How can we get one of these commits? Rather than manually typing out &lt;code&gt;fixup!&lt;/code&gt; in your fixup commit messages, git provides some help: &lt;code&gt;git commit --fixup&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;language-shell&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;$ &lt;span class=&quot;token function&quot;&gt;git&lt;/span&gt; log --oneline&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;# 3333333 (HEAD) Adds dev dependencies.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;# 2222222 Updates README.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;# 1111111 Adds framework boilerplate.&lt;/span&gt;&lt;br&gt;&lt;br&gt;$ &lt;span class=&quot;token function&quot;&gt;git&lt;/span&gt; commit --fixup &lt;span class=&quot;token number&quot;&gt;2222222&lt;/span&gt;&lt;br&gt;$ &lt;span class=&quot;token function&quot;&gt;git&lt;/span&gt; log --oneline&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;# 4444444 (HEAD) fixup! Updates README.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;# 3333333 Adds dev dependencies.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;# 2222222 Updates README.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;# 1111111 Adds framework boilerplate.&lt;/span&gt;&lt;br&gt;&lt;br&gt;$ &lt;span class=&quot;token function&quot;&gt;git&lt;/span&gt; rebase -i --autosquash HEAD~4&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;# * Shown in your text editor:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;# pick 1111111 Adds framework boilerplate.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;# pick 2222222 Updates README.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;# fixup 4444444 fixup! Updates README.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;# pick 3333333 Adds dev dependencies.&lt;/span&gt;&lt;br&gt;&lt;br&gt;$ &lt;span class=&quot;token function&quot;&gt;git&lt;/span&gt; log --oneline&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;# 6666666 (HEAD) Adds dev dependencies.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;# 5555555 Updates README.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;# 1111111 Adds framework boilerplate.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this example, a fixup is committed for commit &lt;code&gt;2222222&lt;/code&gt;, which shows up with &lt;code&gt;fixup!&lt;/code&gt; in its commit title, and ends up getting reordered and labelled as &lt;code&gt;fixup&lt;/code&gt; during the rebase.&lt;/p&gt;
&lt;p&gt;After the rebase is executed you can see that the commit history has been modified, starting at commit &lt;code&gt;5555555&lt;/code&gt; (previously &lt;code&gt;2222222&lt;/code&gt;) where the fixup was applied.&lt;/p&gt;
&lt;h2 id=&quot;text-based-revision-selection-with-%3A%2F&quot;&gt;Text-based revision selection with &lt;code&gt;:/&lt;/code&gt; &lt;a class=&quot;direct-link&quot; href=&quot;#text-based-revision-selection-with-%3A%2F&quot;&gt;ðŸ”—&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In the previous example, in order to create the fixup commit with &lt;code&gt;git commit --fixup 2222222&lt;/code&gt;, we used the commit hash as the identifier (which we found through &lt;code&gt;git log&lt;/code&gt;), but there&#39;s a more intuitive way we can specify which commit we want to fixup, using &lt;code&gt;:/&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Using &lt;code&gt;:/&lt;/code&gt; as a revision identifier tells git to find the most-recent commit which matches the text (really a regular expression) following those tokens.&lt;sup class=&quot;footnote-ref&quot;&gt;&lt;a href=&quot;#fn1&quot; id=&quot;fnref1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt; For example:&lt;/p&gt;
&lt;pre class=&quot;language-shell&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;$ &lt;span class=&quot;token function&quot;&gt;git&lt;/span&gt; log --oneline&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;# 3333333 (HEAD) Adds dev dependencies.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;# 2222222 Updates README.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;# 1111111 Adds framework boilerplate.&lt;/span&gt;&lt;br&gt;&lt;br&gt;$ &lt;span class=&quot;token function&quot;&gt;git&lt;/span&gt; show :/framework&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;# commit 1111111111111111111111111111111111111111&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;# Author: Chili Johnson&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;# Date:   Apr 20 04:20:00 2020 -0000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;# &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;#     Adds framework boilerplate.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;# â€¦&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we can identify the commit to fix using its commit message, instead of having to find and copy the hash of the commit we want to fix. This eliminates part of step 4 of the naÃ¯ve workflow.&lt;/p&gt;
&lt;h2 id=&quot;non-interactive-interactive-rebase&quot;&gt;Non-interactive interactive rebase &lt;a class=&quot;direct-link&quot; href=&quot;#non-interactive-interactive-rebase&quot;&gt;ðŸ”—&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Now we have most of the parts we need for an optimized fixup workflow, but there&#39;s still the problem of &lt;code&gt;--autosquash&lt;/code&gt; and &lt;code&gt;--autostash&lt;/code&gt; only working with interactive rebases. Those two options already do everything we need to do during the rebase so opening up a text editor isn&#39;t useful anymore.&lt;/p&gt;
&lt;p&gt;To disable opening a text editor during the interactive rebase, we can use the &lt;code&gt;GIT_SEQUENCE_EDITOR&lt;/code&gt; environment variable to override the editor which git tries to open.&lt;sup class=&quot;footnote-ref&quot;&gt;&lt;a href=&quot;#fn2&quot; id=&quot;fnref2&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;Overriding it to a program/command which does nothing and exits cleanly will turn an interactive rebase into a non-interactive rebase, while retaining interactive-only features like the two options we&#39;re interested in.&lt;/p&gt;
&lt;pre class=&quot;language-shell&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;# The rebase succeeds without ever opening a text editor&lt;/span&gt;&lt;br&gt;$ &lt;span class=&quot;token assign-left variable&quot;&gt;GIT_SEQUENCE_EDITOR&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;: &lt;span class=&quot;token function&quot;&gt;git&lt;/span&gt; rebase -i HEAD~2&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;# Successfully rebased and updated refs/heads/master.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here we&#39;re using many shells&#39; built-in &lt;code&gt;:&lt;/code&gt; command to do nothing and exit cleanly, which allows the rebase to continue on without requiring any interaction.&lt;/p&gt;
&lt;h1 id=&quot;putting-it-all-together&quot;&gt;Putting it all together &lt;a class=&quot;direct-link&quot; href=&quot;#putting-it-all-together&quot;&gt;ðŸ”—&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;Here is a shell function I use (with &lt;code&gt;zsh&lt;/code&gt;) which combines all of these optimizations into one command which can be used to fixup commits identified by part of their commit message:&lt;/p&gt;
&lt;pre class=&quot;language-shell&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;&lt;span class=&quot;token function-name function&quot;&gt;fixup&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token assign-left variable&quot;&gt;title_match&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;&lt;span class=&quot;token variable&quot;&gt;${@&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt;1}&lt;/span&gt;&quot;&lt;/span&gt;&lt;br&gt;&lt;br&gt;  &lt;span class=&quot;token builtin class-name&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;&lt;span class=&quot;token entity&quot; title=&quot;\n&quot;&gt;\n&lt;/span&gt;This operation will rebase:&lt;span class=&quot;token entity&quot; title=&quot;\n&quot;&gt;\n&lt;/span&gt;&quot;&lt;/span&gt;&lt;br&gt;&lt;br&gt;  &lt;span class=&quot;token function&quot;&gt;git&lt;/span&gt; --no-pager log --oneline &lt;span class=&quot;token string&quot;&gt;&quot;HEAD^{/&lt;span class=&quot;token variable&quot;&gt;$title_match&lt;/span&gt;}^..HEAD&quot;&lt;/span&gt; --reverse&lt;br&gt;&lt;br&gt;  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;token variable&quot;&gt;$?&lt;/span&gt; -ne &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;then&lt;/span&gt;&lt;br&gt;    &lt;span class=&quot;token builtin class-name&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;&lt;span class=&quot;token entity&quot; title=&quot;\n&quot;&gt;\n&lt;/span&gt;Could not find a commit with title matching: &lt;span class=&quot;token entity&quot; title=&quot;\&amp;quot;&quot;&gt;\&quot;&lt;/span&gt;&lt;span class=&quot;token variable&quot;&gt;$title_match&lt;/span&gt;&lt;span class=&quot;token entity&quot; title=&quot;\&amp;quot;&quot;&gt;\&quot;&lt;/span&gt;&quot;&lt;/span&gt;&lt;br&gt;    &lt;span class=&quot;token builtin class-name&quot;&gt;return&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token keyword&quot;&gt;fi&lt;/span&gt;&lt;br&gt;&lt;br&gt;  &lt;span class=&quot;token builtin class-name&quot;&gt;echo&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token builtin class-name&quot;&gt;read&lt;/span&gt; -q &lt;span class=&quot;token string&quot;&gt;&quot;REPLY?Are you sure? &quot;&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token builtin class-name&quot;&gt;echo&lt;/span&gt;&lt;br&gt;&lt;br&gt;  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;token environment constant&quot;&gt;$REPLY&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;~ ^&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;Yy&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;$ &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token keyword&quot;&gt;then&lt;/span&gt;&lt;br&gt;    &lt;span class=&quot;token function&quot;&gt;git&lt;/span&gt; commit --fixup &lt;span class=&quot;token string&quot;&gt;&quot;:/&lt;span class=&quot;token variable&quot;&gt;$title_match&lt;/span&gt;&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;token assign-left variable&quot;&gt;GIT_SEQUENCE_EDITOR&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;: &lt;span class=&quot;token function&quot;&gt;git&lt;/span&gt; rebase --interactive --autostash --autosquash &lt;span class=&quot;token string&quot;&gt;&quot;HEAD^^{/&lt;span class=&quot;token variable&quot;&gt;$title_match&lt;/span&gt;}^&quot;&lt;/span&gt;&lt;br&gt;  &lt;span class=&quot;token keyword&quot;&gt;fi&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;First it prints out which commits will be affected by this rebase and asks for confirmation that all looks good. Then it proceeds to commit any staged changes (stashing any unstaged changes), performs a non-interactive, &amp;quot;interactive&amp;quot; rebase to apply the fixup, and finally restores the unstaged changes to the working tree.&lt;/p&gt;
&lt;p&gt;It accepts one argument, the commit message title fragment (regex) to match the commit intended to be fixed.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Thanks to &lt;a href=&quot;https://www.verychill.biz/&quot; target=&quot;_blank&quot;&gt;Jesse Jenks&lt;/a&gt; for workshopping this function and making it even better!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;An example usage:&lt;/p&gt;
&lt;pre class=&quot;language-shell&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;$ &lt;span class=&quot;token function&quot;&gt;git&lt;/span&gt; log --oneline&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;# 3333333 (HEAD) Adds dev dependencies.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;# 2222222 Updates the readme with an outro.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;# 1111111 Adds framework boilerplate.&lt;/span&gt;&lt;br&gt;&lt;br&gt;$ &lt;span class=&quot;token builtin class-name&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;Thanks for reading&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&gt;&gt;&lt;/span&gt; README.md&lt;br&gt;$ &lt;span class=&quot;token builtin class-name&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;Do whatever you want&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; LICENSE&lt;br&gt;$ &lt;span class=&quot;token function&quot;&gt;git&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;add&lt;/span&gt; README.md&lt;br&gt;$ &lt;span class=&quot;token function&quot;&gt;git&lt;/span&gt; status&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;# Changes to be committed:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;#   modified:   README.md&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;# &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;# Changes not staged for commit:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;#   modified:   LICENSE&lt;/span&gt;&lt;br&gt;&lt;br&gt;$ fixup outro&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;# This operation will rebase:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;# &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;# 2222222 Updates the readme with an outro.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;# 3333333 (HEAD) Adds dev dependencies.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;# &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;# Are you sure? y&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;# [master 4444444] fixup! Updates the readme with an outro.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;#  1 file changed, 1 insertion(+), 1 deletion(-)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;# Created autostash: 2f16c33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;# HEAD is now at 4444444 fixup! Updates the readme with an outro.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;# Applied autostash.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;# Successfully rebased and updated refs/heads/master.&lt;/span&gt;&lt;br&gt;&lt;br&gt;$ &lt;span class=&quot;token function&quot;&gt;git&lt;/span&gt; log --oneline&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;# 6666666 (HEAD) Adds dev dependencies.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;# 5555555 Updates the readme with an outro.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;# 1111111 Adds framework boilerplate.&lt;/span&gt;&lt;br&gt;&lt;br&gt;$ &lt;span class=&quot;token function&quot;&gt;git&lt;/span&gt; status&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;# Changes not staged for commit:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;#   modified:   LICENSE&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;By making use of &lt;code&gt;--autostash&lt;/code&gt;, &lt;code&gt;--autosquash&lt;/code&gt;, &lt;code&gt;:/&lt;/code&gt;, and &lt;code&gt;GIT_SEQUENCE_EDITOR&lt;/code&gt;, we&#39;ve been able to distill that 9-step fixup workflowâ€”which demanded multiple interactive steps and a copy-paste jobâ€”into a single, intuitive command which allows you to apply fixups for selective files while maintaining a dirty working tree.&lt;/p&gt;
&lt;p&gt;I use this all the time in my daily workflow!&lt;/p&gt;
&lt;h4 id=&quot;footnotes&quot;&gt;Footnotes &lt;a class=&quot;direct-link&quot; href=&quot;#footnotes&quot;&gt;ðŸ”—&lt;/a&gt;&lt;/h4&gt;
&lt;hr class=&quot;footnotes-sep&quot;&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;ol class=&quot;footnotes-list&quot;&gt;
&lt;li id=&quot;fn1&quot; class=&quot;footnote-item&quot;&gt;&lt;p&gt;&lt;a href=&quot;https://git-scm.com/docs/gitrevisions#Documentation/gitrevisions.txt-emlttextgtemegemfixnastybugem&quot;&gt;Git Revisions Syntax&lt;/a&gt; &lt;a href=&quot;#fnref1&quot; class=&quot;footnote-backref&quot;&gt;â†©ï¸Ž&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn2&quot; class=&quot;footnote-item&quot;&gt;&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/29094595/git-interactive-rebase-without-opening-the-editor#answer-29094904&quot;&gt;Stack Overflow: Git interactive rebase without opening the editor&lt;/a&gt; &lt;a href=&quot;#fnref2&quot; class=&quot;footnote-backref&quot;&gt;â†©ï¸Ž&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</content>
	</entry>
</feed>
